# -*- coding: utf-8 -*-
"""Adaptive_filters_Stock_Prediction (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mjPM8Dly6kA9758MsIo5N9hKSm7vdDzJ

# Stock Prices Prediction using Adaptive Filters

## Import required libraries
"""

pip list

pip install nasdaq-data-link

pip install padasip

#%matplotlib notebook
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import padasip as pa
#import quandl
import math
import pickle as pk
from matplotlib import style
import nasdaqdatalink
style.use('ggplot')

"""## Import the dataset

Here we have imported the dataset from quandl using the quandl API. The dataset consists of McDonalds End of Day prices from 28-06-2016 to 28-12-2018
"""

nasdaqdatalink.ApiConfig.api_key = "pdp1VhpXmppUs9V2PWE8"
df = nasdaqdatalink.get("BSE/BOM500470",trim_start='2016-06-28', trim_end='2018-12-28', collapse='daily')
df

plt.figure(figsize=(9,4))
plt.ylabel('Closing Prices')
df['Close'].plot(linewidth=1)
plt.show()

df.shape

"""## Data Preprocessing

Here df.info() helps to find out the data type of all the features and also if there are any NaN values in our dataset. As we can see we don't have any NaN values so we don't need to fill them.
"""

df.info()

"""Here we drop features that are not necessary for our prediction."""

df.drop(['Open', 'High', 'Low', 'WAP','No. of Shares','No. of Trades','Total Turnover','Deliverable Quantity','% Deli. Qty to Traded Qty','Spread H-L','Spread C-O'], axis=1, inplace=True)

df['Close']

"""## Preparation of source input and train test split

Here we are generating the source input array, which will be useful in generating the 2D matrix 'x' which will be our input. We will be taking first 360 values as our source input
"""

arr=np.array(df['Close'])
# Specify the percentage of data to use for training (e.g., 80%)
train_percentage = 0.8
# Calculate the index to split the data
split_index = int(len(arr) * train_percentage)
s=arr[:split_index]
s = df['Close'].values.flatten()[:split_index]
n=5

"""## Preparation of Input matrix

We will use the 'input_from_history' function from the Padasip library. It takes 2 parameters: a 1D array which is the source input and n--> filter length. It converts 's' into something called the 'Design Embedded Matrix' (DEM), where number of columns = n and no of rows = N-n+1, where N=length of s.
"""

x = pa.input_from_history(s,n)
N = len(x)
x

"""## Define desired response

The desired response starts from the 6th element of s and continues till the end as the length of the filter = 5
"""

d=np.zeros(len(x))
for i,k in enumerate(range((n-1),N)):   #Here i starts from 0 and k starts from n-1=4. d is our desired response, so it starts
    #from the 5th element. As we use the previous 0-4 elements to predict the 5th element d[0]=s[5]
    d[i]=s[k+1]
d

"""## Build and run the LMS algorithm"""

mu_=0.0000006
f_lms=pa.filters.FilterLMS(n=5,mu=mu_,w='zeros')
y_lms,e_lms,w_lms=f_lms.run(d,x)
y_lms

"""## Plot the actual and predicted data"""

# Commented out IPython magic to ensure Python compatibility.
#%matplotlib notebook
# %matplotlib inline
plt.figure(figsize=(10, 6))
#plt.subplot(211)
plt.title(f'LMS (mu={mu_})')
plt.plot(d[: (len(d)-n)], 'b', label='target',linewidth='1')
plt.plot(y_lms[: (len(y_lms)-n)], 'g', label='predict / output',linewidth='1')
plt.xlabel('Number of days')
plt.ylabel('Closing prices')
plt.legend()
plt.show()

_avg_error_lms = round(np.mean(10*np.log10(e_lms[: (len(e_lms) - n)]**2)), 2)
_avg_error_lms

plt.figure(figsize=(10,6))
plt.axhline(y=_avg_error_lms, color='black', lw=1, linestyle='--')
plt.plot(pa.misc.logSE(e_lms), "r", label="Squared error" , linewidth=1)
plt.title(f'Filter error: Avg error:{_avg_error_lms}')

mse_lms = pa.misc.MSE(e_lms)
rmse_lms = pa.misc.RMSE(e_lms)
mse_lms

rmse_lms

"""## Realtime Prediction"""

s_future=np.array(df['Close'])
s_future=s_future[split_index:]
x_future = pa.input_from_history(s_future,n)
d_future = np.zeros(len(x_future))
N_future = len(x_future)

for i,k in enumerate(range((n-1),N_future)):
    d_future[i] = s_future[k+1]
actual_list_lms = np.zeros(N_future)
pred_list_lms = np.zeros(N_future)

for k in range(N_future):
    x_input = x_future[k]
    y_lms = f_lms.predict(x_input)
    d_actual = d_future[k]
    f_lms.adapt(d_actual,x_input)
    actual_list_lms[k] = d_actual
    pred_list_lms[k] = y_lms

plt.figure(figsize=(10,6))
#plt.subplot(211)
plt.title("Adaptive Filter on future data (simulated)")
plt.xlabel("Samples [k]")
plt.plot(actual_list_lms[: (len(actual_list_lms)-n)], "b", label="actual")
plt.plot(pred_list_lms[: (len(pred_list_lms)-n)], "g", label="predict")
plt.legend()

"""# NLMS filter with similar specifications"""

mu_=1
f_nlms=pa.filters.FilterNLMS(n=5,mu=mu_,w='zeros')
y_nlms,e_nlms,w_nlms=f_nlms.run(d,x)
y_nlms

# Commented out IPython magic to ensure Python compatibility.
#%matplotlib notebook
# %matplotlib inline
plt.figure(figsize=(10, 6))
#plt.subplot(211)
plt.title(f'NLMS (mu={mu_})')
plt.plot(d[: (len(d)-n)], 'b', label='target',linewidth='1')
plt.plot(y_nlms[: (len(y_nlms)-n)], 'g', label='predict / output',linewidth='1')
plt.xlabel('Number of days')
plt.ylabel('Closing prices')
plt.legend()
plt.show()

_avg_error_nlms = round(np.mean(10*np.log10(e_nlms[: (len(e_nlms) - n)]**2)), 2)
_avg_error_nlms

plt.figure(figsize=(10,6))
plt.axhline(y=_avg_error_nlms, color='black', lw=1, linestyle='--')
plt.plot(pa.misc.logSE(e_nlms), "r", label="Squared error" , linewidth=1)
plt.title(f'Filter error: Avg error:{_avg_error_nlms}')

mse_nlms = pa.misc.MSE(e_nlms)
rmse_nlms = pa.misc.RMSE(e_nlms)
mse_nlms

rmse_nlms

"""## Realtime prediction loop - nlms"""

actual_list_nlms = np.zeros(N_future)
pred_list_nlms = np.zeros(N_future)

for k in range(N_future):
    x_input = x_future[k]
    y_nlms = f_nlms.predict(x_input)
    d_actual = d_future[k]
    f_nlms.adapt(d_actual,x_input)
    actual_list_nlms[k] = d_actual
    pred_list_nlms[k] = y_nlms

plt.figure(figsize=(10,6))
#plt.subplot(211)
plt.title("Adaptive Filter on future data (simulated)")
plt.xlabel("Samples [k]")
plt.plot(actual_list_nlms[: (len(actual_list_nlms)-n)], "b", label="actual")
plt.plot(pred_list_nlms[: (len(pred_list_nlms)-n)], "g", label="predict")
plt.legend()

"""# RLS filter with similar specifications"""

#ro is the max limit of the step size
mu_=1.01
f_rls=pa.filters.FilterRLS(n=5,mu=mu_,w='zeros')
y_rls,e_rls,w_rls=f_rls.run(d,x)
y_rls

# Commented out IPython magic to ensure Python compatibility.
#%matplotlib notebook
# %matplotlib inline
plt.figure(figsize=(10, 6))
#plt.subplot(211)
plt.title(f'RLS (mu={mu_})')
plt.plot(d[: (len(d)-n)], 'b', label='target',linewidth='1')
plt.plot(y_rls[: (len(y_rls)-n)], 'g', label='predict / output',linewidth='1')
plt.xlabel('Number of days')
plt.ylabel('Closing prices')
plt.legend()
plt.show()

avg_error_rls = round(np.mean(10*np.log10(e_rls[: (len(e_rls) - n)]**2)), 2)
avg_error_rls

plt.figure(figsize=(10,6))
plt.axhline(y=avg_error_rls, color='black', lw=1, linestyle='--')
plt.plot(pa.misc.logSE(e_nlms), "r", label="Squared error" , linewidth=1)
plt.title(f'Filter error: Avg error:{avg_error_rls}')

mse_rls = pa.misc.MSE(e_rls)
rmse_rls = pa.misc.RMSE(e_rls)
mse_rls

rmse_rls